---
title: "Untitled"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(tidytuesdayR)
library(skimr)
```

```{r}
tuesdata <- tt_load(2021, week = 21)

survey <- tuesdata$survey
```

## cleaning country

```{r}
survey_clean <- survey %>% 
  mutate(
    country_clean = case_when(
      country %in% c("United States", "USA", "US", "U.S.", "United States of America", "Usa", "United states", "usa", "Us", "united states", "U.S.A.", "us", "U.S", "United State", "Unites States", "United States of america", "UNITED STATES", "The United States", "United Sates") ~ "United States",
      country %in% c("United Kingdom", "UK", "Uk", "United kingdom", "uk", "united kingdom") ~ "United Kingdom",
      T ~ country
    )
  )
```

would be cool to write a function that makes all of this a whole lot easier

maybe try binary

```{r}
# def genbin(n, bs=''):
# if len(bs) == n:
#     print(bs)
# else:
#     genbin(n, bs + '0')
#     genbin(n, bs + '1')

binary_strings <- function(n, digits = c('0','1')) {
  if (n <= 0) return(matrix(0,0,0))
  if (n == 1) return(matrix(digits, 2))
  x <- binary_strings(n - 1)
  rbind(cbind(digits[1], x), cbind(digits[2], x))
}


```


```{r}
name_variety <- function(name) {
  
  # separate string into its individual words
  
  words <- str_split(name, " ")[[1]]
  
  # create bistrings
  
  n <- length(words)
  
  binary_tibble <- as_tibble(binary_strings(n))
  
  df_one <- binary_tibble
  for (row in 1:nrow(binary_tibble)) {
     for (col in 1:n) {
      if (binary_tibble[row, col] == '0') {
        df_one[row, col] <- str_to_lower(words[col])
      } else {
        df_one[row, col] <- str_to_upper(words[col])
      }

     }
  }
  
  df_one <- unite(df_one, phrase, 1:ncol(df_one), sep = " ")
  
  unlist(df_one, use.names = F)
  
}



```

Things to check for:

First letter capitalization: Yo Yo, yo Yo, Yo yo, yo yo
entire word capitalization: YO YO, yo yo, YO yo, yo YO











